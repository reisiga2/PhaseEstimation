classdef MixtureD < ProbDistr    %General mixture model, representing    %a weighted mixture of probability density functions.    %    %A MixtureD object can represent random vectors with any form of    %statistical dependence between vector elements, even if each of its    %pdf components does not allow correlated vector elements.    %    %Several MixtureD objects may be collected in a multidimensional array,    %           even if they do not have the same DataSize.    %    %Arne Leijon, 2010-07-14 tested, but not extensively    %           2011-05-25, generalized logprob method, superclass prob method        properties (Access=public)        Selector=DiscreteD;%discrete probability distribution for choice of each component        Comp=GaussD;%  vector with mixed ProbDistr objects.        %UserData   any data structure,        %    end    properties (Access=public,Dependent)        MixWeight;% column vector with prob of each Comp element        DataSize;%  size of data vectors        Mean;%      total mean    end    %------------------------------------------------    methods (Access=public)%Methods for general use        function pD = MixtureD(varargin)%--- Constructor method:            %***Usage:            %pD=MixtureD;            %   creates a single standard object.            %pD=MixtureD(comp);            %   creates a mixture object from array comp, with ProbDistr elements.            %pD=MixtureD(comp,weight); OR            %pD=MixtureD(weight,comp);            %   creates a MixtureD object from array comp,            %   mixed with array weights. (Lengths must match.)            %            switch nargin                case 0%default trivial single-component GMM                case 1                    arg1=varargin{1};                    if isa(arg1,'MixtureD')                        pD= arg1;%just Copy it                    elseif isa(arg1,'ProbDistr')                        pD.Comp = arg1(:);%column vector                        pD.MixWeight = ones(length(pD.Comp),1);%column vector, equal weights                        %else%it should be numeric length of desired GaussD array                        %pD.Gaussians=repmat(GaussD,arg1,1);%Clone trivial GaussD to right length                        %pD.MixWeight = ones(length(pD.Gaussians),1);%column vector                    end;                case 2  %must be a ProbDistr array and a weight vector                    arg1=varargin{1};                    arg2=varargin{2};                    if isa(arg1,'ProbDistr')%                        pD.Comp = arg1(:);%column vector                        pD.MixWeight = arg2(:);                    else%*** reverse argument order                        pD.Comp = arg2(:);%column vector                        pD.MixWeight = arg1(:);                    end;                    if length(pD.Comp) ~= length(pD.MixWeight)                        error('Incompatible array lengths');                    end;                otherwise                    error('Too many arguments');                    %pD=setNamedProperties(pD,varargin{:});%for backward compatibility            end;        end        function [X,S]=rand(pD,nSamples)%generate random vector samples            if numel(pD)>1                error('This method works only for a single MixtureD object');            end;            S=pD.Selector.rand(nSamples);%random integer sequence, with indices of Comp            X=zeros(pD.DataSize,nSamples);            for s=1:max(S)                ns=sum(S==s);%number of samples from component s                if ns>0                    X(:,S==s)=pD.Comp(s).rand(ns);%get from randomly chosen sub-object                end;            end;        end        %***********replaced by superclass prob, 2011-05-25        %         function [f,logS]=prob(pD,x)%probability densities for observed vector samples        %             %Input:        %             %pD=    MixtureD object or multidim array of such objects        %             %x=     matrix with given vectors stored columnwise        %             %        %             %Result:        %             %f=     proportional to probability densities for x        %             %       size(f)== [numel(pD),size(x,2)]        %             %       max f value always =1        %             %logS=  scalar log scalefactor to make sure f is within numerical limits        %             %       f*exp(logS)=   true probability densities for x        %             %        %             %This representation is necessary because the probability density may be        %             %extremely small for random vectors with many elements        %             %        %             %Arne Leijon, 2010-08-25        %        %             nObj=numel(pD);%number of MixtureD objects        %             nx=size(x,2);%number of observed vectors        %             f=zeros(nObj,nx);%init result storage        %             logScale=zeros(nObj,1);%log scale factors        %             for n=1:nObj        %                 [subProb,logScale(n)]=pD(n).Comp.prob(x);%prob from all Comp-s        %                 %********save subProb also, to save time later, in AdaptAccum???        %                 f(n,:)=pD(n).MixWeight'*subProb;%weighted sum        %             end;        %             %if Comp prob==0, then f(n,:)==0 AND logScale==-Inf        %             logS=max(logScale);        %             fscale=max(max(f));%must be >0 for SOME element and SOME obs        %             scale=exp(logScale-logS)./fscale;%same scaling for all objects        %             logS=logS+log(fscale);        %             if logS>-Inf        %                 f=f.*repmat(scale,1,nx);%f*exp(logS)= true prob.density        %             end;        %         end        function logP=logprob(pD,x)            %2011-05-25, more robust version, tested            nObj=numel(pD);%number of GaussMixD objects            nx=size(x,2);%number of observed vectors            logP=zeros(nObj,nx);            for n=1:nObj                logPn=logprob(pD(n).Comp,x);%prob from all sub-Gaussians                logS=max(logPn);                %if length(pD(n).Gaussians)==1, logS is scalar, otherwise                %size(logS)==[1,nx]; might be -Inf or +Inf at some places                logPn=bsxfun(@minus,logPn,logS);%=logPn-logS expanded to matching size                %logPn(k,t) may be NaN for some k, if logS(t)==-Inf, or logS(t)==+Inf                logPn(isnan(logPn(:)))=0;%corrected                logP(n,:)=logS+log(pD(n).MixWeight'*exp(logPn));                %may be +Inf or -Inf at some places, but this is OK            end;        end        %         function h=entropy(pD)%differential entropy (approximate)        %         end        %         function plotH=plotCross(pD,proj,colors)%plot indicators of each mixed sub-object        %         end        %****plotProb  3D plot of probability density function???)        %    end    %---------------------------------------------------    methods(Access=public)%------------- Training Methods:        function pD=init(pD,x)%initialize crudely to conform with given data            %The agreement is very crude, and should be refined by training,            %using methods adaptStart, adaptAccum, and adaptSet.            %            %Input:            %pD=    a single MixtureD object or array of such objects            %x=     matrix with observed vectors stored columnwise            %            %Result:            %pD=    initialized MixtureD object or MixtureD array            %       size(pD)== same as input            %            %Method:            %For a single MixtureD object: let its Comp sub-object do it.            %For a MixtureD array: First init a Comp array, then split each cluster.            %This initialization is crude, and should be refined by training.            %            %Arne Leijon 2006-04-21 tested for GaussMixD                        nObj=numel(pD);            if nObj>0.5*size(x,2)                error('Too few data vectors');end;%***reduce nObj instead???                        if nObj==1                pD.Comp=init(pD.Comp,x);%let sub-Comp do it                nComp=length(pD.Comp);                pD.MixWeight=ones(nComp,1)./nComp;%equal mixweights            else                %first make a single GaussD array, and then split each Comp                g=init(repmat(GaussD,nObj,1),x);%single GaussD at each cluster                [~,bestG]=max(prob(g,x));%assign each data point to nearest GaussD                for i=1:nObj                    [pD(i).Comp,iOK]=init(pD(i).Comp,x(:,bestG==i));%use only nearest data                    if any(~iOK)                        %delete Comp(i) where iOK(i)==0, because of too few data                        pD(i).Comp=pD(i).Comp(iOK==1);                        warning('Mixtured:init:fewData',...                            ['Mixture no.',num2str(i),' reduced to ',num2str(length(pD(i).Comp)),' components']);                    end;                    nComp=length(pD(i).Comp);%number of sub-objects in this mix                    pD(i).MixWeight=ones(nComp,1)./nComp;%equal mixweights                end;            end;        end        function [gm,logprobs]=train(gm,xT,nIterations,minStep)%standard training procedure            %adapts a single MixtureD object to an            %observed set of (possibly vector-valued) samples.            %            %Input:            %gm=    single MixtureD object            %xT=    matrix with a set observed vectors, stored columnwise            %nIterations=   (optional) min number of iterations            %minStep=       (optional) min logprob improvement/training obs.vector            %               = desired improvement in relative entropy/ obs.vector,            %               in each iteration step.            %typically, minStep=log(1.01); for 1% average relative-entropy improvement.            %            %Result:            %gm=    new trained MixtureD object            %logprobs=  vector with mean logprob/obs.vector, achieved during training            %            %Method: apply methods adaptStart, adaptAccum, and adaptSet.            %       The MixtureD must be previously initialized to the format of the            %       training data.            %            %Arne Leijon 2009-07-21 tested in GaussMixD                        if numel(gm)>1                error('Method works only for single object');            end;            if nargin<3                nIterations=10;end;%default            if nargin<4                minStep=realmax;%to prevent conditional training steps                % else                %     minStep=minStep*size(xT,2);%min desired increment in total logprob            end;            logPold=-realmax;%            logP=mean(logprob(gm,xT),2);%before any training            logprobs=zeros(1,nIterations);%space for minimal number of training steps            for nTraining=1:nIterations%min number of iterations                logPold=logP;                aS=adaptStart(gm);                aS=adaptAccum(gm,aS,xT);                gm=adaptSet(gm,aS);                logP=mean(logprob(gm,xT),2);                logprobs(nTraining)=logP;%accumulate training result                %    display(logPold);display(logP);%testing            end;            while logP-logPold>minStep%continue training if sufficiently good improvement                logPold=logP;                aS=adaptStart(gm);                aS=adaptAccum(gm,aS,xT);                gm=adaptSet(gm,aS);                logP=mean(logprob(gm,xT),2);                logprobs=[logprobs,logP];                %    display(logPold);display(logP);%testing            end;        end        function plotH=plotCross(pD,proj,colors)%2D plot of projected Mean and StDev            for n=1:numel(pD)                nC=1+mod(n-1,length(colors));%single color for this object                plotH=pD(n).Comp.plotCross(proj,colors(nC));%let the component array do it                hold on;            end;            hold off;        end        %        %--------------------- Low-level training methods:        %These methods can be used also to adapt several MixtureD objects,        %automatically assigning training vectors to different objects,        %if no external obsWeight is given in call to adaptAccum.        %        function aS=adaptStart(pD)%initialize accumulator data structure for data statistics            %to be used in subsequent calls to method adaptAccum and adaptSet.            %            %Input:            %pD=    MixtureD object or array of such objects            %            %Result:            %aS=    data structure to be used by methods adaptAccum and adaptSet.            %            %Theory is discussed in method adaptSet            %            %Arne Leijon 2010-07-13                        nObj=numel(pD);            aS=repmat(struct('Comp',[],'MixWeight',[]),nObj,1);%init struct storage            for i=1:nObj%one storage set for each object in the array                aS(i).Comp=adaptStart(pD(i).Comp);%to adapt sub-object Comp                aS(i).MixWeight=zeros(length(pD(i).MixWeight),1);%to adapt MixWeight            end;                    end        function aS=adaptAccum(pD,aS,obsData,obsWeight)%collect statistics from observed data,            %           without changing the object itself            %           (may be called repeatedly with different data subsets).            %            %Usage:            %First obtain the storage data structure aState from method adaptStart.            %Then, adaptAccum can be called several times with different observation data subsets.            %The aS data structure must be saved externally between calls to adaptAccum.            %Finally, the GaussMixD object(s) are updated by method adaptSet.            %            %Input:            %pD=        a MixtureD object or multidim array of such objects            %aS=        accumulated adaptation state preserved from previous calls,            %           first obtained from method adaptStart            %obsData=   matrix with observed column vectors,            %           each assumed to be drawn from one of the GaussMixD objects            %obsWeight= (optional) matrix with weight factors, one column for each vector in obsData,            %           and one row for each object in the GaussMixD array            %           size(obsWeight)== [length(pD(:)), size(obsData,2)]            %           obsWeight(i,t)= prop to P( GaussMixD(t)=i | obsData)            %           obsWeight must have consistent values for all calls.            %            %Result:            %aS=        accumulated adaptation data, incl. this observation data set.            %            %Arne Leijon 2005-02-14 tested for GaussMixD                        nData=size(obsData,2);%number of given vector samples            nObj=numel(pD);%n of GaussMixD objects in array            if nargin<4%no external obsWeight given                if nObj==1                    obsWeight=ones(nObj,nData);%use all data with equal weight                else                    obsWeight=prob(pD,obsData);%assign weight to each GaussMixD object                    obsWeight=obsWeight./repmat(sum(obsWeight),nObj,1);                    %obsWeight(i,t)= P(mixS(t)= i | obsData)= P(GaussMixD(i)-> X(t))                end;            end;            for i=1:nObj%for all objects                %***find sub-Object probabilities for each mixed Comp element                %can be done instead by the sub-Object itself ??????                %NO, because sub-Object also needs our obsWeight                nSubObj=length(pD(i).Comp);                if nSubObj==1%no need for extra computation                    aS(i).Comp=adaptAccum(pD(i).Comp,aS(i).Comp,obsData,obsWeight(i,:));                    aS(i).MixWeight=aS(i).MixWeight+sum(obsWeight(i,:),2);                else                    subProb=prob(pD(i).Comp,obsData);%saved from previous call instead???                    %subProb(j,t)=P(X(t)=obsData(:,t) | subS(t)=j & mixS(t)=i )                    subProb=diag(pD(i).MixWeight)*subProb;%fix Arne Leijon, 2009-10-11                    %subProb(j,t)=P(X(t)=obsData(:,t) & subS(t)=j | mixS(t)=i )                    denom=max(realmin,sum(subProb,1));%2005-02-14: avoid division by zero in next statement                    subProb=subProb./repmat(denom,nSubObj,1);%normalize to conditional prob.s                    %subProb(j,t)=P(subS(t)=j| X(t)=obsData(j,t) & mixS(t)=i )                    subProb=subProb.*repmat(obsWeight(i,:),nSubObj,1);%scale by externally given weights                    %subProb(j,t)=P(mixS(t)=i & subS(t)=j| X(1:T)=obsData(:,1:T) )                    aS(i).Comp=adaptAccum(pD(i).Comp,aS(i).Comp,obsData,subProb);                    aS(i).MixWeight=aS(i).MixWeight+sum(subProb,2);                end;            end;        end        function pD=adaptSet(pD,aS)%finally adjust the object using accumulated statistics.            %Input:            %pD=        MixtureD object or array of such objects            %aS=    accumulated statistics from previous calls of adaptAccum            %            %Result:            %pD=        adapted version of the MixtureD object            %            %Theory and Method:            %The sub-object array pD(i).Comp must have its own adaptSet method.            %In addition, this method adjusts the pD(i).MixWeight vector,            %   simply by normalizing the accumulated sum of MixWeight vectors,            %   for the observed data.            %            %References:            %   Leijon (200x). Pattern Recognition            %   Bilmes (1998). A gentle tutorial of the EM algorithm.            %            %Arne Leijon 2004-11-15 tested for GaussMixD                        for i=1:numel(pD)%for all objects                pD(i).Comp=adaptSet(pD(i).Comp,aS(i).Comp);%sub-Comp sets itself                pD(i).MixWeight=aS(i).MixWeight./sum(aS(i).MixWeight);%set normalized MixWeight            end;%easy!!!        end        %        %         %***** Special methods for MI calculation        %         [trfD,tState] = transform(pD,tState, trfObj,transformFcn,varargin);        %         %       transform distribution as Y=g(X)+U, with possibly non-linear g()        %         MI = transfMI(pD,noiseCov);        %         %       mutual information I(Y;X) between transformed input and output        %         %[logpX,pU]=logsubprob(pD,u,x);% ***NOT NEEDED ???    end    %-------------------------------------------------------------------    methods%------------------------------------------ get/set methods        function D=get.DataSize(pD)            D=pD.Comp(1).DataSize;%same for all Comp elements within each MixtureD        end        function M=get.Mean(pD)%total mean, over all mixed components            mk=zeros(pD.DataSize,length(pD.Comp));            for k=1:length(pD.Comp)                mk(:,k)=pD.Comp(k).Mean;%store in matrix columns            end;            M=mk*pD.MixWeight;%weighted overall mean vector        end        function pD=set.Comp(pD,gg)%check type and DataSize            if ~isa(gg,'ProbDistr')                error('Comp must be array of ProbDistr objects');            end            if ~equalDataSize(gg)                error('All mixed components must have same DataSize');            end;            pD.Comp=gg;%all seems OK            function ok=equalDataSize(gD)                ds=gD.DataSize;%for all objects                ok=all(ds==ds(1));            end        end        function w=get.MixWeight(pD)            w=pD.Selector.ProbMass;%get prob from the Selector object            %w=w(:);%ensure column vector, regardless of historical DiscreteD implementation        end        function pD=set.MixWeight(pD,w)            pD.Selector=DiscreteD(w);%incl normalization as needed        end    end    %     methods (Access='private')    %          function pD=setNamedProperties(pD,varargin)%for backward compatibility    %          %set named property value    %          %several (propName,value) pairs may follow.    %             property_argin = varargin;    %             while length(property_argin) >= 2,    %                 propName = property_argin{1};    %                 v = property_argin{2};    %                 property_argin = property_argin(3:end);    %                 switch propName    %                     case {'MixWeight'}% for backward compatibility    %                         pD.MixWeight=v(:);    %                     case 'Gaussians'    %                         pD.Gaussians=v(:);    %                     otherwise    %                         error(['Cannot set property ',propName,' of this object']);    %                 end;    %             end;    %         end    %     endend